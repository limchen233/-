### 对Virtual DOM的理解

虚拟DOM在`Vue.js`主要做了两件事：

- 提供与真实DOM节点所对应的虚拟节点`vnode`
- 将虚拟节点`vnode`和旧虚拟节点`oldVnode`进行对比，然后更新视图

**虚拟DOM的最终目标是将虚拟节点渲染到视图上。**

但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的操作。例如，一个`ul`标签下有很多个`li`标签,其中只有一个`li`有变化，这种情况下如果使用新的`ul`去替代旧的`ul`,因为这些不必要的DOM操作而造成了性能上的浪费。

为了实现高效的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（`oldVnode`）做对比，**我们通过 patch 的核心—-`diff `算法，找出本次DOM需要更新的节点来更新，其他的不更新**。

### 为何需要Virtual DOM？

- 具备跨平台的优势

由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、`Weex`、`Node `等。

- 操作 DOM 慢，`js`运行效率高。我们可以将DOM对比操作放在`JS`层，提高效率。

因为DOM操作的执行速度远不如`Javascript`的运算速度快，因此，把大量的DOM操作搬运到`Javascript`中，运用`diff`算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。

Virtual DOM 本质上就是在 `JS `和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 `JS `和 DOM 之间加个缓存。CPU（`JS`）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）

- 提升渲染性能

Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。

### `diff `算法的实现过程

`diff `算法本身非常复杂，实现难度很大。粗略介绍以下两个核心函数实现流程：

- patch(`container`,`vnode`) :初次渲染的时候，将`VDOM`渲染成真正的DOM然后插入到容器里面。
- patch(`vnode`,`newVnode`):再次渲染的时候，将新的`vnode`和旧的`vnode`相对比，然后之间差异应用到所构建的真正的DOM树上。