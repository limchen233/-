### `HTTPS由来`

HTTP大家都知道，平时发送请求都是通过HTTP协议，使用起来方便简单，然而HTTP并非只有好的一面，它也是有不足之处的。

HTTP主要有这些不足：

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

如果在HTTP协议通信过程中使用未经加密的明文，比如在Web页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。

为了统一解决上述这些问题，需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为`HTTPS`（HTTP Secure）。

`HTTPS`并非是应用层的新协议。只是HTTP通信接口部分用`SSL(Secure Socket Layer)`和`TLS(Transport Layer Security)`代替而已。

通常，HTTP直接和TCP通信。当使用`SSL`时，则演变成先和`SSL`通信，再由`SSL`和TCP通信了。

![image-20210715134306831](https://github.com/limchen233/picgo/blob/master/img/image-20210715134306831.png?raw=true)

在采用`SSL`后，HTTP就拥有了`HTTPS`的加密、证书和完整性保护这些功能。

`SSL(Secure Socket Layer)`是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合`SSL`协议使用。可以说`SSL`是当今世界上应用最为广泛的网络安全技术。

> `SSL`技术最初是由浏览器开发商网景通信公司率先倡导的，开发过`SSL3.0`之前的版本。目前主导权已转移到`IETF`（Internet Engineering Task Force,Internet工程任务组）的手中。
>
> `IETF`以`SSL3.0`为基准，后又制定了`TLS1.0`、`TLS1.1`和`TLS1.2`。`TSL`是以`SSL`为原型开发的协议，有时会统一称该协议为`SSL`。当前主流的版本是`SSL3.0`和`TLS1.0`。

### 加密方法

加密有共享密钥加密和公开密钥加密。

共享密钥加密也叫做对称密钥加密，即加密和解密同用一个密钥的方式。以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入第三方之手，同时也就失去了加密的意义。

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

`HTTPS`采用共享密钥加密和公开密钥加密两者并用的混合加密机制。因为公开密钥加密与共享密钥加密相比，其处理速度要慢。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

### CA

公开密钥虽说比较安全，但还是存在一些问题。那就是无法证明公开密钥本身是真实的公开密钥。

比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。

为了解决上述问题，可以使用由数字证书认证机构（CA,Certificate Authority）和其相关机关颁发的公开密钥证书。

**数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。**

首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。

服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。

接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。（多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥）

### `HTTPS`通信步骤

![image-20210715145329779](https://github.com/limchen233/picgo/blob/master/img/image-20210715145329779.png?raw=true)

1. 客户端通过发送`Client Hello`报文开始`SSL`通信。报文中包含客户端支持的`SSL`的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行`SSL`通信时，会以`Server Hello`报文作为应答。和客户端一样，在报文中包含`SSL`版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送`Certificate`报文。报文中包含公开密钥证书。
4. 最后服务器发送`Server Hello Done`报文通知客户端，最初阶段的`SSL`握手协商部分结束。
5. `SSL`第一次握手结束之后，客户端以`Client Key Exchange`报文作为回应。报文中包含通信加密中使用的一种被称为`Pre-master secret`的随机密码串。该报文已用步骤3中的公开密钥进行加密。
6. 接着客户端继续发送`Change Cipher Spec`报文。该报文会提示服务器，在此报文之后的通信会采用`Pre-master secret`密钥加密。
7. 客户端发送`Finished`报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送`Change Cipher Spec`报文。
9. 服务器同样发送`Finished`报文。
10. 服务器和客户端的`Finished`报文交换完毕之后，`SSL`连接就算建立完成。当然，通信会受到`SSL`的保护。从此处开始进行应用层协议的通信，即发送`HTTP`请求。
11. 应用层协议通信，即发送`HTTP`响应。
12. 最后由客户端断开连接。断开连接时，发送`close_notify`报文。上图做了一些省略，这步之后再发送`TCP FIN`报文来关闭与`TCP`的通信。



> 备注：
>
> `HTTPS`请求虽说安全可靠，但并不是所有请求都要使用`HTTPS`。
>
> 因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。
>
> 因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用`HTTPS`加密通信。特别是每当那些访问量较多的Web网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。

