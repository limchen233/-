## 什么是浏览器缓存

`浏览器缓存(Brower Caching)`是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有：

1. 减少了冗余的数据传输，节省了带宽
2. 减少了服务器的负担，大大提升了网站的性能
3. 加快了客户端加载网页的速度

在前端开发面试中，浏览器缓存是web性能优化面试题中很重要的一个知识点，从而说明浏览器缓存是提升web性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以，结合最近遇到的案例，本文对浏览器缓存相关的知识进行总结归纳。

## 浏览器缓存的分类

浏览器缓存主要有两类：`强缓存`和`协商缓存`。 

浏览器在第一次请求发生后，再次请求时：

1. 浏览器会先获取该资源缓存的header信息，根据其中的`expires`和`cahe-control`判断是否命中`强缓存`，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；
2. 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（`Last-Modified/IF-Modified-Since、Etag/IF-None-Match`）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。

#### 强缓存

强缓存是利用`http`的返回头中的`Expires`或者`Cache-Control`两个字段来控制的，用来表示资源的缓存时间。 

**Expires** 该字段是`http1.0`时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如`Expires:Mon,18 Oct 2066 23:59:59` GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

 **Cache-Control** Cache-Control是`http1.1`时出现的header信息，主要是利用该字段的`max-age`值来进行判断，它是一个相对时间，例如`Cache-Control:max-age=3600`，代表着资源的有效期是3600秒。Cache-control除了该字段外，还有下面几个比较常用的设置值：

- no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在`ETag`，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
- no-store：禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
- public：可以被所有的用户缓存，包括终端用户和`CDN、Nginx`等中间代理服务器。
- private：所有内容只有客户端可以缓存，不允许`CDN、Nginx`等中继缓存服务器对其缓存。**Cache-Control的默认取值**
- `max-age=xxx`：缓存内容将在`xxx`秒后失效

> **注意：Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。**

#### 协商缓存

协商缓存就是由**`服务器来确定缓存资源`**是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是`成对`出现的，即第一次请求的响应头带上某个字段（`Last-Modified`或者`Etag`），则后续请求则会带上对应的请求字段（`If-Modified-Since`或者`If-None-Match`），若响应头没有`Last-Modified`或者`Etag`字段，则请求头也不会有对应的字段。

 **`Last-Modify/If-Modify-Since`** 浏览器第一次请求一个资源的时候，服务器返回的header中会加上`Last-Modify`，`Last-modify`是一个时间标识，返回该资源文件在**服务器**最后被修改的时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。 当浏览器再次请求该资源时，request的请求头中会包含`If-Modify-Since`，该值为缓存之前返回的`Last-Modify`。服务器收到`If-Modify-Since`后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回`Last-Modify`。

 **`ETag/If-None-Match`** 与**`Last-Modify/If-Modify-Since`**不同的是，**`Etag/If-None-Match`**返回的是一个校验码。`Etag`是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。`ETag`可以保证每一个资源是唯一的，资源变化都会导致`ETag`变化。服务器根据浏览器请求时的`If-None-Match`值来判断是否命中缓存。 与`Last-Modified`不一样的是，当服务器返回`304 Not Modified`的响应时，由于`ETag`重新生成过，`response header`中还会把这个`ETag`返回，即使这个`ETag`跟之前的没有变化。 

> **强缓存与协商缓存异同：**
>
> - **两者的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；**
> - **两者的区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。**



### Last-Modified 与 `ETag`

你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`Etag`呢？`HTTP1.1`中`Etag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了N次)，`If-Modified-Since`能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录`MTIME`只能精确到秒)；
- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。

## 如果服务端没有设置 Cache-Control 怎么办 （同时没有Expires）？

浏览器有自己的优化策略。

以`chorme`浏览器为例：

第一次：协商缓存，询问服务端，资源是否改变，已改变则发起请求。没改变的话，304重定向，并根据响应头的date和last-modified计算出强制缓存的时间（类似强制设置 Cache-Control: max-age=xx）。

第二次开始：就有强制缓存了，状态码为200。

## **`ETag`**

`ETag`是作为一个缓存验证令牌的字符串，这通常是文件内容的hash值。服务器可以在其响应中包括`ETag`，然后浏览器可以在请求中使用它（在文件过期之后），以便确定缓存是否包含过时的副本。如果hash相同，则资源未更改，服务器就以304状态码（未修改）来响应空主体，也就是说浏览器知道使用缓存副本仍然是可行的。不过要注意的是，`ETag`仅在文件从缓存过期时用于请求。

