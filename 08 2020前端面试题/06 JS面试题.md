1.`get`请求怎么设置不缓存？

- 在header中设置`cache-control`属性为`no-store`（`no-cache`是不强制缓存）
- 在get请求的`url`中增加随机标识，比如时间戳(这个方法只是让浏览器不会从缓存中读取数据，缓存还是在的，只不过带上时间戳使每次请求的`url`都不一样，这样每次都会向服务器发送请求得到最新数据)

2.`setTimeout`和`nextTick`的区别？

- `nextTick`()早于`setTimeout`()执行。
- 它们都属于异步任务，异步任务又分成本轮循环和次轮循环（循环就是指event loop），Node规定`process.nextTick`和`Promise`的回调函数追加在本轮循环，即同步任务一旦完成，就开始执行它们。而`setTimeout`、`setInterval`、`setImmediate`的回调函数，追加在次轮循环。JavaScript 引擎处理异步任务的方式是本轮循环**一定早于**次轮循环执行。

3.`var、let、function`定义变量的区别？

- var的创建和初始化被提升，赋值不会被提升
- let的创建被提升，初始化和赋值不会被提升
- function的创建、初始化和赋值均会被提升
- 补充：`const`声明的基本类型变量不可改变，且声明时就要赋值，否则会报错。

4.前端发送请求时的安全性怎么做？

后端加密会生成`token`，`token`会保存在`responseHeader`里的`set-cookie`属性里，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

在封装好的`axios`中将`withCredentials`属性设置为`true`,每次请求时允许带上`cookie`。

5.`http`状态码

- 200 请求成功
- 301 永久重定向
- 302 临时重定向
- 304 请求的资源没有修改过
- 400 请求无法被服务器理解（语义有误、参数有误）
- 403 禁止访问
- 404 请求的资源不存在
- 500 服务器内部错误
- 502 网关错误
- 503 服务器不可用

6.怎么解决浏览器跨域？

- `jsonp`、`cors`、服务器代理

- 利用`cors`。Access-Control-Allow-Origin属性设为*

`jsonp`是需要前端处理，原理是利用了`<script>`标签的`src`属性

(1)创建script标签 

```javascript
var script = document.createElement('script')
```

(2)设置回调函数

```javascript
// 数据请求回来会被触发的函数，data是请求回来的数据
function getData(data){
  //处理逻辑
  console.log(data)
}
```

(3)设置script的`src`属性，即设置请求地址

```
script.src = 'http://www.123.com?callback=getData'
```

(4)让script生效

```javascript
document.body.appendChild(script)
```

7.`axios`怎么设置跨域？`axios`拦截器怎么设置？

`axios.default.crossDomain` = true

8.深拷贝与浅拷贝的区别？

浅拷贝只能拷贝一层，深拷贝可以拷贝多层

**9.怎么让promise变成同步？**

异步promise封装使用then链式操作转同步

在简洁一下就是使用`async await` 封装

**10.`promise`怎么取消或中断**

- 原promise对象的状态将跟新对象保持一致

```javascript
Promise.resolve().then(() => {
    console.log('ok1')
    return new Promise(()=>{})  // 返回“pending”状态的Promise对象
}).then(() => {
    // 后续的函数不会被调用
    console.log('ok2')
}).catch(err => {
    console.log('err->', err)
})
```

- `Promise.race`竞速方法可以让后续的promise不再执行
- 当promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获。

**11.在项目中如何把`http`的请求换成`https`**

(1)由于我在项目中是会对`axios`做一层封装，所以每次请求的域名也是写在配置文件中，有一个`baseURL`字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求`http`为`https`了。

(2)利用`meta`标签把`http`请求换为`https`:

```html
<meta http-equiv ="Content-Security-Policy" content="upgrade-insecure-requests">
```

**12.`axios`设置超时**

- `axios.default.timeout` = 30*1000

**13.`cookie/localStorage/sessionStorage`的区别？**

cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般`4K`左右，而`sessionStorage`与`localStorage`大小在5兆左右，在客户端生成。

`localStorage`和`sessionStorage`一样都是用来存储客户端临时信息的对象。

`localStorage`生命周期是永久，这意味着除非用户显式的在浏览器提供的UI上清除`localStorage`信息，否则这些信息将永远存在。

`sessionStorage`仅在当前会话下有效，关闭页面或浏览器后被清除。刷新页面`sessionStorage`信息还在。

`cookie`在与服务器端通信每次都会携带在`HTTP`头中，如果使用`cookie`保存过多数据会带来性能问题,而`sessionStorage`与`localStorage`仅在客户端（即浏览器）中保存，不参与和服务器的通信。

不同浏览器无法共享`localStorage`或`sessionStorage`中的信息。相同浏览器的不同页面间可以共享相同的 `localStorage`（页面属于相同域名和端口），但是不同页面或标签页间无法共享`sessionStorage`的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个`iframe`标签且他们属于同源页面，那么他们之间是可以共享`sessionStorage`的。

**14.`forEach`怎么打断？**

- 除了抛出异常以外，没有办法中止或跳出 `forEach()` 循环
- 如果想提前终止循环，请使用其它遍历方式（for、for...in、for...of）

> 直接用break会报错，return也不会打断循环(只是终止了本次继续执行，不是终止循环)

```javascript
try {
  var list = [1, 3, 4, 5, 6, 7, 9]

  list.forEach(function (e) {
    if (e > 3) throw new Error('退出循环')
    console.log(e)
  })
} catch (error) {
  if(error.message !== '退出循环') throw error
}
```

**15.一个表单中添加一个按钮，给这个按钮添加一个事件，点击按钮会发生什么？**

- 点击按钮会刷新页面，因为表单有默认提交行为。

> 解决：
>
> a.表单内的<button>未指定类型时，默认的类型为submit，可以显示的修改为<button type="button">来阻止表单提交
>
> b.利用`preventDefault()`方法
>
> ```html
> <html>
>   <head>
>     <meta charset="UTF-8">
>     <title>测试</title>
>     <script>
>     	function test(event){
>         event.preventDefault()
>       }
>     </script>
>   </head>
>   <body>
>     <form action="">
>       <input type="submit" value="button" onclick="test(event)"/>
>     </form>
>   </body>
> </html>
> ```
>
> c.将代码中的<input> type 改为 button 也可以阻止表单默认刷新行为
>
> d.将action设为action=“`javascript:;`”或者action=“`javascript:void(0)`”

**16.`slice、substring、substr`的区别和相同之处？**

- `slice,substring,substr`三个函数都是截取字符串，但是对参数的处理有区别
- `slice(start,end)`和`substring(start,end)`,他们两个的`end`都是原字符串的索引，意思为截取到end（不包括end）位置的字符，即包左不包右。end可省略，如果省略该参数，它们会一直提取到字符串末尾。
- slice中的start和end可以为负数，-1表示倒数第一个，-2表示倒数第2个。
- substring中的任一参数不能为负，如果参数小于0或为`NaN`，则被当作0；如果任一参数大于所给字符串长度，则被当作字符串长度；如果end大于start，它的执行结果就像两个参数调换了一样。
- 首先`String.prototype.substr()`并非JavaScript核心语言的一部分，虽然没有严格被废弃，但它被认作是遗留的函数并且可以的话应该避免使用。
- `substr(start,length)`，`start`为开始提取字符的位置，如果为负值，则被看作`strLength + start`；如果`start`为正值，且大于或等于字符串的长度，则`substr`会返回一个空字符串；如果 `start` 为负值，则 `substr` 把它作为从字符串末尾开始的一个字符索引。如果 `start` 为负值且 `abs(start)` 大于字符串的长度，则 `substr` 使用 0 作为开始提取的索引。length为提取的字符个数，与前两个方法不一样。length为可选，如果省略length，则提取到字符串末尾；如果length为负值或0，则`substr`会返回一个空字符串。