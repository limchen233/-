<img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163137583.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216162331170.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163554503.png?raw=true" style="zoom: 33%;" /><img src="https://github.com/limchen233/picgo/blob/master/img/image-20201216163823081.png?raw=true" style="zoom:33%;" /> 



首页日常任务模块--->日常任务列表（父组件）-->任务列表（子组件）-->详情页（孙组件）

需求如图，就是从首页进入功能列表页父组件，滚动一段距离点击`自立项目`进入到任务子组件，再滚动一段距离点击`第一条带日期的那一项`进入任务详情，然后返回时要返回到刚才滚动的位置，而不是从列表第一条开始。

项目使用的`vue`框架和`vant`组件，我按照`vue`官方文档里介绍说把`<router-view>`用`<keep-alive>`包裹起来就可以实现，各组件内也定义了`name`属性，然而并没有卵用，每次返回都是从第一条显示。网上搜了下大概有两个原因：

1、`<router-view>`嵌套在层级不同的`<router-view>`中切换会出现缓存数据失效。

2、`<keep-alive>`只对直属的子组件有效，**多个共用组件导致的`<keep-alive>`缓存失效**。

解决方法：

1、既然是多个`router-view`嵌套并且共用的情况下造成的，那么如果只存在一个`router-view`，也就是只需要`app.vue`作为框架内所有页面的容器，就不会有这个问题。然后将`router`转换一下，全部转换成一级路由。

2、不转换路由层级，使用`scrollIntoView()`或者获取父组件的`scrollTop`。

> `Element`接口的`scrollIntoView()`方法会滚动元素的父容器，使被调用`scrollIntoView()`的元素对用户可见。[具体请参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)
>
> `Element.scrollTop` 属性可以获取或设置一个元素的内容垂直滚动的像素数。一个元素的 `scrollTop` 值是这个元素的**内容顶部**（卷起来的）到它的视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 `scrollTop` 值为`0`。[scrollTop](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)

我在项目中使用了第二种解决方案，因为我觉得带层级的路由更清晰些。而且有的页面功能类似，采用封装好的通用组件可以减少大量代码。（在一级路由中引用封装的组件也可能造成缓存失败）

因为`scrollIntoView()`只能设置滚动位置为`start/center/end/nearest`，滚动位置并不精确，体验不是太好，而且兼容性没有`scrollTop`好，所以选择了 `Element.scrollTop` 。

注意：这里有个坑，**`scrollTop`一定要获取父组件的，即使是在子组件也要获取父组件的`scrollTop`**。我一开始是获取的子组件和`vant`列表的`scrollTop`，不管怎么滚动`scrollTop`一直为0，纠结了不少时间。

具体操作步骤：

1、首先在父组件内获取到最外层元素

```vue
// 父组件
<template>
  <div class="dailyTaskMain commonStyle" ref="dailyTaskMain">
    // 封装的通用组件，里面包含了vant列表，点击列表中的自立项目时会触发getScroll函数
    <CommonParentPage @getScroll="getScroll"></CommonParentPage>
    <!-- 显示子路由 -->
    <router-view></router-view>
  </div>
</template>
<script>
  export default {
    data () {
      return {
        scroll: ''
      }
    },
    watch: {
    	// 监测路由路径变化，返回父路由时，刷新滚动距离
      $route (now, old) {
        if ((old.name === 'dailyChildTask') && (now.name === 'dailyTask')) {
          // 刷新滚动距离（一定要放在nextTick函数里，赋值才会成功）
          this.$nextTick(() => {
            this.$refs.dailyTaskMain.scrollTop = this.scroll
          })
        }
      }
    },
    methods: {
      // 获取滚动距离
      getScroll () {
        this.scroll = this.$refs.dailyTaskMain.scrollTop
      }
    }
  }
</script>
```

这样就拿到了父组件的滚动距离，而且从子组件返回时，会自动定位到滚动的位置。完美解决！