需求就是从列表页点击进入查看详情，返回时刚才点击的那条还在可视区内，（假如滚动了一段距离）而不是从第一条开始。

项目使用的`vue`框架和`vant`组件，我按照`vue`官方文档里介绍说把`<router-view>`用`<keep-alive>`包裹起来就可以实现，各组件内也定义了`name`属性，然而并没有卵用。网上搜了下大概有两个原因：

1、`<router-view>`嵌套在层级不同的`<router-view>`中切换会出现缓存数据失效。

2、`<keep-alive>`只对直属的子组件有效，**多个共用组件导致的`<keep-alive>`缓存失效**。

解决方法：

1、既然是多个`router-view`嵌套并且共用的情况下造成的，那么如果只存在一个`router-view`，也就是只需要`app.vue`作为框架内所有页面的容器，就不会有这个问题。然后将`router`转换一下，全部转换成一级路由。

2、不转换路由层级，使用`scrollIntoView()`或者获取父组件的`scrollTop`。

> `Element`接口的`scrollIntoView()`方法会滚动元素的父容器，使被调用`scrollIntoView()`的元素对用户可见。[具体请参考](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)
>
> `Element.scrollTop` 属性可以获取或设置一个元素的内容垂直滚动的像素数。一个元素的 `scrollTop` 值是这个元素的**内容顶部**（卷起来的）到它的视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 `scrollTop` 值为`0`。[scrollTop](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)

我在项目中使用了第二种解决方案，因为我觉得带层级的路由更清晰些。

因为`scrollIntoView()`只能设置`star/center/end/nearest`，滚动位置并不精确，体验不是太好，而且兼容性没有`scrollTop`好，所以选择了 `Element.scrollTop` 。



