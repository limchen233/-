### 执行上下文

执行上下文一般分为`全局上下文`、`函数上下文`、`块级上下文`。

**`全局上下文`**：是最外层的上下文。在浏览器中，全局上下文就是我们所说的`window`对象，因此所有通过`var`定义的全局变量和函数都会成为`window`对象的属性和方法。

使用`let`和`const`的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。

上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出 前才会被销毁，比如关闭网页或退出浏览器）。

**`函数上下文`**：每个函数都有自己的上下文。当代码执行流进入函数时，函数的上下文衩推到一个`上下文栈`上。在函数执行完之后，`上下文栈`会弹出该函数上下文，将控制权返还给之前的执行上下文。

> 注：全局上下文的变量对象始终是作用域链的最后一个变量对象。



### 作用域链

上下文中的代码在执行的时候，会创建对象的一个`作用域链`(scope chain)。这个作用域链决定了各级上文中的代码在访问变量和函数时的顺序。正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量：`arguments`。（全局上下文中没有这个变量）

作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）



**注：**

> 1、执行上下文分全局上下文、函数上下文和块级上下文。
> 2、代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。
> 3、函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下	  文中的变量。
> 4、全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。
> 5、变量的执行上下文用于确定什么时候释放内存。