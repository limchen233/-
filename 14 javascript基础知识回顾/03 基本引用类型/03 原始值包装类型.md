`ECMAScript`提供了3种特殊的引用类型：`Boolean、Number、String`。这些类型具有引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。**每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法，操作完又自动销毁。**

例子：

```javascript
let s1 = 'some text'
let s2 = s1.substring(2)
/**
 s1是一个包含字符串的变量，它是一个原始值；
 第二行在s1上调用了substring方法，并把结果保存在s2中；
 我们知道，原始值本身不是对象，因此逻辑上不应该有方法，但是这个例子又确实按照预期运行了。这是因为后台作了处理。
*/
```

后台执行的操作：

- 创建一个`String`类型的实例
- 调用实例上的特定方法
- 销毁实例

```javascript
// 代码实现
let s1 = new String('some text')
let s2 = s1.substring(2)
s1 = null
```

这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。

> 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new实例化引用 类型后，得到的实例会在离开作用域时被销毁，而**自动创建的原始值包装对象则只存在于访问它的那行代码期间**。这意味着不能在运行时给原始值添加属性和方法。
>
> **在原始值包装类型的实例上调用`typeof`会返回`object`，所有原始值包装对象都会转换为布尔值true。**



**Boolean**

Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入true或false

```javascript
let booleanObject = new Boolean(true)
```

Boolean的实例会重写`valueOf()`方法，返回一个原始值`true`或`false`。`toString()`方法被调用时也会被覆盖，返回字符串`"true"`或`"false"`。

