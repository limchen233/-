`ECMA-262`描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、布尔操作符（`！、&&、||`）、相等操作符（如`==、===`）、赋值操作符（`=`）等。我们主要说一下位操作符和指数操作符。

`位操作符`用于数值的底层操作，也就是操作内存中表示数据的比特（位）。`ECMAScript`中的所有数值都以`IEEE754` 64位格式存储，但**位操作符并不直接应用到64位表示，而是先把值转为32位整数，**再进行位操作，之后再把结果转换为64位。

有符号整数使用32位的前31位表示整数值。第32位表示数值的符号，如0表示正，1表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即31位中的每一位都代表2的幂。第一位（称为第0位）表示2的0次方，第二位表示2的1次方 ，依此类推。如果一个位是空的，则以0填充，相当于忽略不计。比如，数值18的二进制格式为00000000000000000000000000010010，或更精简的10010。后者是用到的5个有效位，决定了实际的值。

负值以一种称为**二补数**的二进制编码存储。一个数值的二补数通过如下3个步骤计算得到：

（1）确定绝对值的二进制表示

（2）找到数值的一补数，即每个0都变成1，每个1都变成0

（3）给结果加1

比如`-18`，首先从`18`的二进制表示开始：0000 0000 0000 0000 0000 0000 0001 0010

然后计算一补数，即反转`18`的二进制值：1111 1111 1111 1111 1111 1111 1110 1101

最后给一补数加1变成：1111 1111 1111 1111 1111 1111 1110 1110

那么`-18`的二进制表示就是1111 1111 1111 1111 1111 1111 1110 1110

要注意的是，在处理有符号整数时，我们无法访问第31位。`ECMAScript`会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：

```
let num = -18;
console.log(num.toString(2)); // "-10010"
```

在将`-18`转换为二进制字符串时，结果得到`-10010`。转换过程会求得二补数，然后再以更符合逻辑的形式表示出来。

> **注意**
>
> 默认情况下，`ECMAScript`中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。



1、**按位非**

按位非操作符用波浪符（ ~ ）表示，它的作用是返回数值的一补数。按位非是`ECMAScript`中为数不多的几个二进制数学操作符之一。看下面的例子：

```
let num1 = 25 // 二进制为 00000000000000000000000000011001
let num2 = ~num1 // 二进制为 11111111111111111111111111100110
console.log(num2) // -26

```

这里，按位非操作符作用到了数值25，得到的结果是-26。由此可以看出，**按位非的最终效果是对数值取反并减1。**就像执行如下操作的结果一样：

```
let num1 = 25
lete num2 = -num - 1
console.log(num2) // -26
```

> 尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。

2、**按位与**

按位与操作符用和号（ & ）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 0    |
| 0              | 1              | 0    |
| 0              | 0              | 0    |

按位与操作在两个位都是1时返回1，在任何一位是0时返回0。

我们对数值25和3求与操作：

```
let result = 25 & 3
console.log(result) // 1
```

计算过程：

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

3、**按位或**

按位或操作符用管道符（ | ）表示，同样有两个操作数。按位或遵循如下真值表：

| 第一个数值的值 | 第二个数值的值 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 1    |
| 0              | 1              | 1    |
| 0              | 0              | 0    |

按位或操作在至少一位是1时返回1，两位都是0时返回0。

还是以25和3为例，执行按位或：

```
let result = 25 | 3;
console.log(result);  // 27
```

计算过程：

```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

4、**按位异或**

按位异或用脱字符（ ^ ）表示，同样有两个操作数。下面是按位异或的真值表：

| 第一个数的位 | 第二个数的位 | 结果 |
| ------------ | ------------ | ---- |
| 1            | 1            | 0    |
| 1            | 0            | 1    |
| 0            | 1            | 1    |
| 0            | 0            | 0    |

按位异或与按位或的区别是，它只在一位上是1的时候返回1（两位都是1或0，则返回0）。
对数值25和3执行按位异或操作：

```
let result = 25 ^ 3;
console.log(result);  // 26
```

计算过程：

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

5、**左移**

左移操作符用两个小于号（ << ）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位（即在后面加5个0），就会得到64（二进制1000000），如下所示：

```
let oldValue = 2; // 等于二进制10
let newValue = oldValue << 5; // 等于二进制1000000，即十进制64
```

> 1、在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值。
>
> 2、左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。

6、**有符号右移**

有符号右移由两个大于号（ >> ）表示，会将数值的所有32位都向右移（去掉后面5位，然后在前面加5个0），同时保留符号（正或负）。有符号右移实际上是左移的逆运算。比如，如果将64右移5位，那就是2：

```
let oldValue = 64; // 等于二进制1000000
let newValue = oldValue >> 5; // 等于二进制10，即十进制2
```

> 移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后。`ECMAScript`会用符号位的值来填充这些空位，以得到完整的数值。

7、**无符号右移**

无符号右移用3个大于号表示（ >>> ），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。仍然以前面有符号右移的例子为例，64向右移动5位，会变成2：

```
let oldValue = 64; // 等于二进制1000000
let newValue = oldValue >>> 5; // 等于二进制10，即十进制2
```

对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：

```
let oldValue = -64; // 等于二进制11111111111111111111111111000000
let newValue = oldValue >>> 5; // 等于十进制134217726
```

> 在对-64无符号右移5位后，结果是134 217 726。这是因为-64的二进制表示是11111111111111111111111111000000，无符号右移却将它当成正值，也就是4 294 967 232。把这个值右移5位后，结果是00000111111111111111111111111110，即134 217 726。