继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。**接口继承在`ECMAScript`中是不可能的，因为函数没有签名**。**实现继承是`ECMAScript`唯一支持的继承方式**，而这主要是通过**原型链**实现的。

#### 1、原型链

原型链继承基本思想就是通过原型链继承多个引用类型的属性和方法。

重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。

#### 2、默认原型

默认情况，所有引用类型都继承自Object，这也是通过原型链实现的。任何函数的默认原型都是一个Object的实例，这意味着这个实例有一个内部指针指向`Object.prototype`。这也是为什么自定义类型能够继承包括`toString()、valueOf()`在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系。

完整的原型链关系：

![image-20211019171323140](https://github.com/limchen233/picgo/img/image-20211019171323140.png)

`SubType`继承`SuperType`，而`SuperType`继承Object。在调用`instance.toString()`时，实际上调用的是保存在`Object.prototype`上的方法。

#### 3、原型与继承关系

原型与实例的关系可以通过两种方式来确定。

第一种方式是使用`instanceof`操作符，如果一个实例的原型链中出现过相应的构造函数，则`instanceof`返回true。

```js
console.log(instance instanceof Object) // true
console.log(instance instanceof SuperType) //true
console.log(instance instanceof SubType) // true
```

instance是`Object、SuperType和SubType`的实例，因为instance的原型链中包含这些构造函数的原型。结果就是`instanceof`对所有这些构造函数都返回true。

第二种方式是使用`isPrototypeOf()`方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回true。

```js
console.log(Object.prototype.isPrototypeOf(instance)) // true
console.log(SuperType.prototype.isPrototypeOf(instance)) // true
console.log(SubType.prototype.isPrototypeOf(instance)) // true
```

#### 4、原型链的问题

原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。

原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。

#### 5、继承的方式

1. 盗用构造函数
2. 组合继承
3. 原型式继承
4. 寄生式继承
5. 寄生式组合继承