## 工厂模式

工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。

```js
function createPerson(name,age,job){
  let o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function(){
    console.log(this.name)
  }
  return o
}

let p1 = createPerson('jack',22,'Doctor')
let p2 = createPerson('mark',23,'Teacher')
```

函数`createPerson()`接收3个参数，根据这几个参数构建了一个包含Person信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3个属性和1个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。



## 构造函数模式

##### 1、什么是构造函数

任何函数只要使用new操作符调用就是构造函数。

而不使用new操作符调用的函数就是普通函数。

```js
// 用构造函数重写上面的例子
function Person(name,age,job){
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function(){
    console.log(this.name)
  }
}
let p1 = new Person('jack',22,'Doctor')
let p2 = new Person('mark',23,'Teacher')
p1.sayName() // 'jack'
p2.sayName() // 'mark'
```

##### 构造函数和工厂函数的区别：

- 没有显式的创建对象
- 属性和方法直接赋值给了this
- 没有return
- 函数名首字母大写（构造函数名称的首字母要大写，这是惯例）

##### 调用构造函数的执行过程：

要创建构造函数的实例，应使用new操作符。会执行如下操作：

- 在内存中创建一个新对象
- 这个新对象内部的`[[prototype]]`特性被赋值为构造函数的`prototype`属性
- 构造函数内部的this被赋值为这个新对象（即this指向新对象）
- 执行构造函数内部的代码（给新对象添加属性）
- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

`p1`和`p2`分别保存着Person的不同实例。这两个对象都有一个constructor属性指向Person

```js
console.log(p1.constructor == Person) // true
console.log(p2.constructor == Person) // true
```

constructor本来是用于标识对象类型的。不过，一般认为`instanceof`操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是Object的实例，同时也是Person的实例，如下面调用`instanceof`操作符的结果所示：

```js
console.log(p1.instanceof Object) // true
console.log(p1.instanceof Person) // true
console.log(p2.instanceof Object) // true
console.log(p2.instanceof Person) // true
```

定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。

构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。



## 原型模式

##### 1、什么是原型

每个函数都会创建一个`prototype`属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。

使用原型对象的好处：**原型上定义的属性和方法可以被对象实例共享**。

```js
/**
原型模式
*/
function Person(){}
Person.prototype.name = 'jack'
Person.prototype.age = '22'
Person.prototype.sayName = function(){
  console.log(this.name)
}

let p1 = new Person()
p1.sayName() // 'jack'

let p2 = new Person()
p2.sayName() // 'jack'

console.log(p1.sayName === p2.sayName) // true
```



##### 2、理解原型

只要创建一个函数，就会按照特定的规则为这个函数创建一个`prototype`属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为`constructor`的属性，指向与之关联的构造函数。

在自定义构造函数时，原型对象默认只会获得`constructor`属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部`[[Prototype]]`指针就会被赋值为构造函数的原型对象。脚本中没有访问这个`[[Prototype]]`特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露`__proto__`属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：**实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有**。

